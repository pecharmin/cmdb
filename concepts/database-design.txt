Database Design
===============
The logical table structure of the CMDB is defined here.
You also find a short concept how the fields should be used.

* All data expect roles, permissions, tags and options is an object!
  Tags and options are only references to objects.
* Use PostgreSQL because they have MVCC and recursive queries.


### CMDB Core (.cmdb.core) ###

Entity relationship model
=========================

                   +------ 1:1 ---->  tags
    references_\   |
    archive        | +--- 1:1 -->  options
                   | |
      ^   ^        | |  +--------------- 1:1 ----------------+
      |   |        | |  |                                    |
      |  n:m       v v  v                                    |
      |   |                                                  |
      |   +----->  objects  <-+-- 1:n -->  objects_archive   |
  +---+   |                                                  |
  |      n:m       ^   ^                      ^   ^          |
  |       |      +-+   |                      |   |          |
  |       v      |     |               +------+  n:1         |
  |              |    1:1              |          |          |
  |  references  |     |               |       +--+          |
  |              |     +-+   +-- 1:n --+       |             |
  |       ^      |       |   |                 |  +----------+
  |       |      |       |   |                 |  |
  |       |     1:n      v   v                 v  v
  |       |      |
  |       |      |   permissions  <-- 1:1 -->  roles  <--+- 1:n -+
  |       |      |                                       |       |
  |       |      |         ^                   ^  ^     1:n      v
  |       |      +---+     |                   |  |      |
  |       |          |    1:n   +----- n:1 ----+  |      |    archive_\
  |       |          |     |    |                 |      |    membership_\
  |       |          v     v    v                 |      |    archive
  |       |                                       |      v
  |       |       permissions_archive             |
  |       |                                       |   archive_\
  +-------+-------------- n:1 --------------------+   membership



objects -- Stores all data in objects
======
id			bigint		not null	PK	serial
value			bytea		null
value_type		enum(Types)	not null
name			varchar(120)	null
version			integer		not null
mtime			datetime	not null
locked_by_role_id	integer		null		FK core.roles(id)

Types: object, integer, double, text, blob

* The objects table stores tree objects and data attributes.

* A object is unique identifiable by it's id.
* A tree object is identified by value_type = 'object'.
* In reverse, a attribute is of another type of value_type, not 'object'.
* The name column sets the name (non unique) of an attribute.
* The version field displayes how often the object has been modified.
* The mtime column saves the timestamp of last modification.
* If the locked_by_role_id is set in an object, it is locked for a role
  and can not be modified by others.

* When a object is inserted the id, value_type and mtime is copied with a
  version number of 0 to the objects_archive table. The role id of the
  author is set there in the modified_by_role_id column.
  The mtime of a entry with a version of 0 is the time of creation.
* If a object is modified it will be copied to the objects_archive table
  before. When saving the object with new data, the value of
  locked_by_role_id is copied to the archive to the modified_by_role_id
  column.
* On object removal the data is copied like on a modification to the
  objects_archive table an after this removed from the objects table.


objects_archive -- Archives modified objects as a history
==============
id			bigint		not null	PK
value			bytea		null
value_type		enum(Types)	not null
name			varchar(120)	null
version			integer		not null	PK
mtime			datetime	not null
modified_by_role_id	integer		not null	FK core.roles(id)

Types: object, integer, double, text, blob

* Saves the modified objects as history.
  Whenever a object is modified, the row is copied before to this table.

* A row can clearly be identified by the combination of it's id and version
  column.
* The modified_by_role_id column displays the role id of one who created,
  modified or deleted the object.
* The other fields have same meaning as the fields of the objects table.

* The modified_by_role_id column saves in general the role which changed
  the objects data.
* If no row of an entry in the objects_archive table can be found in the
  objects table, it was offically deleted. The entry with the highest
  version is the last snapshot from the objects table. The column
  modified_by_role_id saved then the role id which deleted the object.
* A entry with version number 0 saves the creator of an object.


references -- Links the objects as a tree togehter.
==========
object_id		bigint	 	not null	UI FK core.objects(id)
referenced_object_id	bigint		null		UI FK core.objects(id)
reference_type		enum(Types)	not null	UI
version			integer		not null
mtime			datetime	not null
locked_by_role_id	integer		null		FK core.roles(id)

Types: parent, link

* This tables links the objects with references togehter.
* A reference can be of type parent or link.
* A reference is clearly identifiable the the object id, the
  referenced object id and the reference type. This is ensured by an
  unique index and assures that a object can't have more than one parent or
  linked multiple time for the same use.

* version, mtime and locked_by_role_id are used in the same way like the
  fields of the objects table and also equally handled.


references_archive -- Saves modified object references.
==========
object_id		bigint	 	not null
referenced_object_id	bigint		null
reference_type		enum(Types)	not null
version			integer		not null
mtime			datetime	not null
modified_by_role_id	integer		not null	FK core.roles(id)

* The tables saves all modified references. 
* A entry can be identified by it's object_id, referenced_object_id,
  reference_type and version.

* The version, mtime and modified_by_role_id fields and their usage are now
  self-explained by their parents ;)


\/ TODO \/


roles -- Defines users and groups for permission handling
=====
id		int unsigned		not null	PK	auto_increment
type		enum(Roles)		not null

Roles: user, group, system

* The role id is the interface to a used authentication backend.
* Created roles can never be changed after they have been created.
* The first role is the system account for internal data handling (options).


roles_membership -- Assigns roles to roles like groups or user cloning
==========
role_id		int unsigned		not null	FK
add_role_id	int unsigned		not null	FK

* role_id is the role which is member of the role add_role_id.
* User rights can be cloned if a users role is added to another user role.
* If the role in add_role_id is of type 'grp' this is like grouping users.
* Roles of the type group can also be members of a group role.


permissions -- Grants permissions for objects to roles
===========
object_id	bigint unsigned		not null	FK
role_id		int unsigned		not null	FK
permission	tinyint unsigned	not null

Permissions:
1 = read
2 = write

* Permissions are applied recursive over a object tree and can only be
  overwritten by higher permissions.
* When a permission is changed, it will be copied with the role_id of the user
  who changed it to the permissions audit table.


permissions_audit -- Save the changed permissions as a trace
=================
object_id	bigint unsigned		not null	FK
role_id		int unsigned		not null	FK
permission	int unsigned		not null
changed_by_role	int unsigned		not null
atime		datetime		not null		default=now()

* The permissions audit table traces all changes on the permissions table.
* atime means there audit time.


options -- Stores application internal options
=======
name		varchar(120)		not null	PK	unique index
object_id	bigint unsigned		not null	FK

* The option name should be dot notated like '.core.object.archive.not-on-modify'.
* The value for this option is stored in the objects table.
* Options can not be saved complete as objects because there is no human readable
  unique identifier.



### CMDB Database Auth (.cmdb.core.auth.db) ###

TODO

auth_db_users -- Stores user information in the database
=============
role_id		int unsigned	not null	FK
username	varchar(40)	not null	unique index
email		varchar(250)	not null
password	char(128)	null
last_login	datetime	null
...


auth_db_groups -- Storges group information to roles in database
==============
role_id		int unsigned	not null	FK
groupname	varchar(40)	not null	unique index
...



### CMDB LDAP Auth (.cmdb.core.auth.ldap) ###

TODO
